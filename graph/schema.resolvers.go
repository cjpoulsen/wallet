package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"context"
	"fmt"
	"github.com/google/uuid"

	"github.com/cjpoulsen/wallet/graph/model"
)

// Credit is the resolver for the credit field.
func (r *mutationResolver) Credit(ctx context.Context, walletID string, amount int32) (*model.Wallet, error) {
	if amount <= 0 || amount > 100 {
		return nil, fmt.Errorf("invalid amount")
	}

	id, err := uuid.Parse(walletID)
	if err != nil {
		return nil, err
	}

	wallet := r.Wallets[id]

	wallet.Balance += amount

	return wallet, nil
}

// Create is the resolver for the create field.
func (r *mutationResolver) Create(ctx context.Context, startingBalance int32) (*model.Wallet, error) {
	id := uuid.New()

	wallet := &model.Wallet{
		ID:      id.String(),
		Balance: startingBalance,
	}

	if r.Wallets == nil {
		r.Wallets = make(map[uuid.UUID]*model.Wallet)
	}

	r.Wallets[id] = wallet

	return wallet, nil
}

// Withdraw is the resolver for the withdraw field.
func (r *mutationResolver) Withdraw(ctx context.Context, walletID string, amount int32) (*model.Wallet, error) {
	id, err := uuid.Parse(walletID)
	if err != nil {
		return nil, err
	}

	wallet := r.Wallets[id]

	if wallet.Balance < amount {
		return nil, fmt.Errorf("insufficient funds")
	}

	wallet.Balance -= amount

	return wallet, nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context, walletID string) (*int32, error) {
	id, err := uuid.Parse(walletID)
	if err != nil {
		return nil, err
	}

	return &r.Wallets[id].Balance, nil
}

// Wallet is the resolver for the wallet field.
func (r *queryResolver) Wallet(ctx context.Context, id string) (*model.Wallet, error) {
	walletId, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	return r.Wallets[walletId], nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
