package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"context"
	"fmt"
	sqlc "github.com/cjpoulsen/wallet/sql"
	"github.com/google/uuid"
	"time"

	"github.com/cjpoulsen/wallet/graph/model"
)

// Credit is the resolver for the credit field.
func (r *mutationResolver) Credit(ctx context.Context, walletID string, amount int32) (*model.Wallet, error) {
	if amount <= 0 || amount > 100 {
		return nil, fmt.Errorf("invalid amount")
	}

	id, err := uuid.Parse(walletID)
	if err != nil {
		return nil, err
	}

	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("error withdrawing funds")
	}
	defer tx.Rollback()

	qtx := r.WithTx(tx)
	wallet, err := qtx.GetWallet(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error retrieving wallet")
	}

	if amount+wallet.Balance > 1000 {
		return nil, fmt.Errorf("balance exceeds maximum")
	}

	wallet.Balance = wallet.Balance + amount

	err = qtx.UpdateBalance(ctx, sqlc.UpdateBalanceParams{ID: id, Balance: wallet.Balance, UpdateDate: time.Now()})
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error updating balance")
	}
	err = tx.Commit()
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error updating balance")
	}

	return &model.Wallet{
		ID:      id.String(),
		Balance: wallet.Balance,
	}, nil
}

// Create is the resolver for the create field.
func (r *mutationResolver) Create(ctx context.Context, startingBalance int32) (*model.Wallet, error) {
	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error creating wallet")
	}
	defer tx.Rollback()

	id := uuid.New()

	qtx := r.WithTx(tx)

	now := time.Now()
	_, err = qtx.CreateWallet(ctx, sqlc.CreateWalletParams{
		ID:         id,
		Balance:    startingBalance,
		CreateDate: now,
		UpdateDate: now,
	})

	err = tx.Commit()
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error creating wallet")
	}

	return &model.Wallet{
		ID:      id.String(),
		Balance: startingBalance,
	}, nil
}

// Withdraw is the resolver for the withdraw field.
func (r *mutationResolver) Withdraw(ctx context.Context, walletID string, amount int32) (*model.Wallet, error) {
	id, err := uuid.Parse(walletID)
	if err != nil {
		return nil, err
	}

	tx, err := r.DB.BeginTx(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("error withdrawing funds")
	}
	defer tx.Rollback()

	qtx := r.WithTx(tx)
	wallet, err := qtx.GetWallet(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("error retrieving wallet")
	}

	if wallet.Balance < amount {
		return nil, fmt.Errorf("insufficient funds")
	}

	wallet.Balance = wallet.Balance - amount

	err = qtx.UpdateBalance(ctx, sqlc.UpdateBalanceParams{ID: id, Balance: wallet.Balance, UpdateDate: time.Now()})
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error updating balance")
	}
	err = tx.Commit()
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error updating balance")
	}

	return &model.Wallet{
		ID:      id.String(),
		Balance: wallet.Balance,
	}, nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context, walletID string) (*int32, error) {
	id, err := uuid.Parse(walletID)
	if err != nil {
		return nil, err
	}

	found, err := r.GetWallet(ctx, id)
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error retrieving wallet")
	}

	return &found.Balance, nil
}

// Wallet is the resolver for the wallet field.
func (r *queryResolver) Wallet(ctx context.Context, id string) (*model.Wallet, error) {
	walletId, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	found, err := r.GetWallet(ctx, walletId)
	if err != nil {
		fmt.Println(err)
		return nil, fmt.Errorf("error retrieving wallet")
	}

	return &model.Wallet{
		ID:      found.ID.String(),
		Balance: found.Balance,
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
